はい、承知いたしました。
これまでの修正を反映した、バックエンドとフロントエンドのコード全文を以下に記載します。他の部分は一切変更していません。

-----

### \#\# バックエンド (`server.js`)

```javascript
import express from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import { VertexAI } from '@google-cloud/vertexai';
import { randomUUID } from 'crypto'; // 受付番号を生成するために追加

// --- ES Modulesで __dirname を再現するための設定 ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.static(path.join(__dirname, 'public')));

// --- Google Cloud Vertex AI の設定 ---
const PROJECT_ID = process.env.GCP_PROJECT_ID;
const LOCATION = 'us-central1';
const vertex_ai = new VertexAI({ project: PROJECT_ID, location: LOCATION });
const generativeModel = vertex_ai.getGenerativeModel({ model: 'gemini-1.5-flash-001' });
const generativeVisionModel = vertex_ai.getGenerativeModel({ model: 'imagen-3.0-fast-generate-001' });

// --- ▼▼▼ 新しい部分：処理状況を保存する場所 ▼▼▼ ---
// サーバーのメモリ上に一時的に保存します。（サーバーが再起動すると消えます）
const imageGenerationJobs = {};

// --- APIエンドポイント ---

app.post('/api/generate-text', async (req, res) => {
    // この部分は変更なし
    const { prompt } = req.body;
    if (!prompt) return res.status(400).json({ error: 'prompt は必須です。' });
    try {
        const geminiResponse = await generativeModel.generateContent(prompt);
        const textResponse = geminiResponse.response.candidates[0].content.parts[0].text;
        const jsonMatch = textResponse.match(/{[\s\S]*}/);
        if (jsonMatch && jsonMatch[0]) {
            res.status(200).json(JSON.parse(jsonMatch[0]));
        } else {
            throw new Error('AIの応答から有効なJSONを見つけられませんでした。');
        }
    } catch (error) {
        console.error('テキスト生成エラー:', error);
        res.status(500).json({ error: 'サーバー側でテキストの生成に失敗しました。', details: error.message });
    }
});

// --- ▼▼▼ 新しいAPI：画像生成の "受付" をする ▼▼▼ ---
app.post('/api/request-image-generation', (req, res) => {
    console.log(`[${new Date().toISOString()}] /api/request-image-generation endpoint hit.`);
    const { storyHistory, theme } = req.body;

    // 受付番号（Job ID）を生成
    const jobId = randomUUID();

    // 処理状況を「処理中」として保存
    imageGenerationJobs[jobId] = { status: 'pending', data: null };
    
    // すぐに「受付ました」とJob IDをフロントエンドに返す
    res.status(202).json({ jobId });

    // --- バックグラウンドで重い処理を開始 ---
    // ここでは await せずに、処理を開始させるだけ（Fire and Forget）
    (async () => {
        try {
            const simplePrompt = `${storyHistory.join('. ')}, theme of ${theme}, cinematic lighting, detailed, photorealistic`;
            console.log(`[Job ID: ${jobId}] Starting image generation with prompt: ${simplePrompt}`);
            
            const imageResponse = await generativeVisionModel.generateContent({
                contents: [{ role: 'user', parts: [{ text: simplePrompt }] }],
                generationConfig: { "number_of_images": 1, "aspectRatio": "9:16" }
            });

            const imageBase64 = imageResponse.response.candidates?.[0]?.content?.parts?.[0]?.fileData?.data;
            if (!imageBase64) {
                throw new Error('AIから画像データを取得できませんでした。');
            }

            // 処理が成功したら、結果を保存
            imageGenerationJobs[jobId] = { status: 'completed', data: imageBase64 };
            console.log(`[Job ID: ${jobId}] Image generation completed.`);

        } catch (error) {
            console.error(`[Job ID: ${jobId}] Image generation failed:`, error);
            // 処理が失敗したら、ステータスを「失敗」に更新
            imageGenerationJobs[jobId] = { status: 'failed', data: error.message };
        }
    })();
});


// --- ▼▼▼ 新しいAPI：画像生成の "状況確認" をする ▼▼▼ ---
app.get('/api/check-image-status/:jobId', (req, res) => {
    const { jobId } = req.params;
    const job = imageGenerationJobs[jobId];

    if (!job) {
        return res.status(404).json({ status: 'not_found' });
    }

    // 現在の処理状況をフロントエンドに返す
    res.status(200).json(job);
});


// どのAPIルートにも一致しない場合、index.htmlを返す
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.listen(PORT, () => {
    console.log(`サーバーがポート ${PORT} で起動しました。`);
});

```

-----

### \#\# フロントエンド (`public/index.html`)

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>起承転結 物語メーカー</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap');
        body { font-family: 'Noto Serif JP', serif; background-color: #2c2c2c; color: #e0e0e0; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        .container { text-align: center; background: #3a3a3a; padding: 30px 40px; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.5); max-width: 600px; width: 100%; transition: all 0.5s ease; }
        #cover-image-container { display: none; margin-bottom: 25px; animation: fadeIn 1.2s forwards; }
        #cover-image { max-width: 60%; height: auto; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.6); border: 2px solid #555; }
        #title-display { font-size: 1.5em; font-weight: bold; color: #ffc107; margin-bottom: 15px; display: none; animation: fadeIn 1s forwards; }
        #act-display { font-size: 1em; color: #ccc; margin-bottom: 25px; border-bottom: 1px solid #555; padding-bottom: 15px; font-weight: bold; }
        #story-log { margin-bottom: 30px; text-align: left; line-height: 2; border-left: 3px solid #666; padding-left: 20px; min-height: 100px; }
        #story-log p { margin: 0 0 1em 0; opacity: 0; animation: fadeIn 0.8s forwards; }
        #story-log p:last-child { font-weight: bold; color: #fff; }
        .option-btn { background: #4a4a4a; border: 1px solid #666; color: #e0e0e0; border-radius: 8px; padding: 15px 30px; font-size: 1.1em; cursor: pointer; transition: all 0.2s ease-in-out; width: 100%; font-family: 'Noto Serif JP', serif; }
        .option-btn:hover:not(:disabled) { background-color: #5a5a5a; border-color: #888; transform: translateY(-2px); }
        .option-btn:disabled { opacity: 0.7; cursor: not-allowed; }
        #loading { display: none; margin-top: 20px; font-size: 1.2em; color: #aaa; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        #user-input-area { width: 100%; animation: fadeIn 0.5s; display: none; }
        #user-input-area > p { margin-top: 20px; margin-bottom: 15px; font-weight: bold; font-size: 1.1em; }
        #recommend-options { display: flex; flex-direction: column; gap: 15px; }
        .input-separator { margin: 25px 0 15px; font-size: 1em; color: #ccc; font-weight: bold; }
        .input-group { display: flex; gap: 10px; margin-top: 10px; }
        #user-word-input { flex-grow: 1; padding: 15px; border-radius: 8px; border: 1px solid #666; background-color: #2c2c2c; color: #e0e0e0; font-family: 'Noto Serif JP', serif; font-size: 1em; transition: border-color 0.2s; }
        #user-word-input:focus { border-color: #ffc107; outline: none; }
        #submit-word-btn { background: #ffc107; color: #2c2c2c; border: none; padding: 15px 20px; border-radius: 8px; cursor: pointer; font-family: 'Noto Serif JP', serif; font-weight: bold; font-size: 1em; transition: background-color 0.2s; white-space: nowrap; }
        #submit-word-btn:hover { background-color: #ffca2c; }
        #end-options-container { margin-top: 20px; display: flex; flex-direction: column; gap: 15px; }
    </style>
</head>
<body>
    <div class="container">
        <div id="cover-image-container">
            <img id="cover-image" src="" alt="生成された物語の表紙">
        </div>
        <div id="title-display"></div>
        <div id="act-display"></div>
        <div id="story-log"></div>
        <div id="loading">物語のテーマを決めています...</div>
        <div id="user-input-area">
            <p id="input-prompt-message">物語を動かす「鍵」となる単語を入力、または選んでください</p>
            <div class="input-group">
                <input type="text" id="user-word-input" placeholder="自由な単語を入力...">
                <button id="submit-word-btn">この単語で続ける</button>
            </div>
            <p class="input-separator">― おすすめの単語 ―</p>
            <div id="recommend-options"></div>
        </div>
        <div id="end-options-container"></div>
    </div>

    <script>
        const coverImageContainer = document.getElementById('cover-image-container');
        const coverImageElem = document.getElementById('cover-image');
        const titleDisplayElem = document.getElementById('title-display');
        const actDisplayElem = document.getElementById('act-display');
        const storyLogElem = document.getElementById('story-log');
        const loadingElem = document.getElementById('loading');
        const userInputArea = document.getElementById('user-input-area');
        const recommendOptions = document.getElementById('recommend-options');
        const userWordInput = document.getElementById('user-word-input');
        const submitWordBtn = document.getElementById('submit-word-btn');
        const endOptionsContainer = document.getElementById('end-options-container');

        const themes = ["日本の現代文学風", "子供向けの心温まるおとぎ話", "ハードボイルドな探偵小説", "宇宙を舞台にしたSF", "甘酸っぱい青春恋愛ストーリー", "壮大なファンタジー叙事詩", "シュールな不条理演劇", "時代小説","複雑な人間関係を描いた人間ドラマ","ホラー小説","ライトノベル","ワクワクする少年向け小説","日常生活を描いた心温まる小説"];
        let selectedTheme = "";
        let storyHistory = [];
        let choiceCount = 0;
        const MAX_RETRIES = 3;

        async function apiCallWithRetry(prompt, retries = MAX_RETRIES) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch('/api/generate-text', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: prompt }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.details || `サーバーエラー: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`API呼び出しに失敗 (試行 ${i + 1}):`, error);
                    if (i === retries - 1) { return null; }
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            loadingElem.style.display = 'block';
            selectedTheme = themes[Math.floor(Math.random() * themes.length)];
            actDisplayElem.textContent = "【起】";
            loadingElem.textContent = "物語の始まりを考えています...";
            const initialPrompt = `# 役割: あなたは「${selectedTheme}」の作家です。\n# 指示: 物語の魅力的な「始まりの一文」を一つだけ生成してください。\n# 制約: 回答は必ず {"sentence": "生成された始まりの一文。"} のJSON形式のみで、説明やマークダウンは一切含めないでください。\n# 出力:`;
            const data = await apiCallWithRetry(initialPrompt);
            if (data && data.sentence) {
                storyHistory.push(data.sentence);
                addSentenceToLog(data.sentence);
                await generateRecommendedWords();
            } else {
                loadingElem.style.display = 'none';
                storyLogElem.innerHTML = `<p>物語を始めることができませんでした。ネットワーク接続を確認して、もう一度お試しください。</p>`;
                endOptionsContainer.innerHTML = `<button class="option-btn" onclick="location.reload()">もう一度試す</button>`;
            }
        });

        async function proceedWithWord(word) {
            document.querySelectorAll('.option-btn').forEach(btn => btn.disabled = true);
            submitWordBtn.disabled = true;
            userWordInput.disabled = true;

            const trimmedWord = word.trim();
            if (!trimmedWord) {
                alert('単語を入力してください。');
                document.querySelectorAll('.option-btn').forEach(btn => btn.disabled = false);
                submitWordBtn.disabled = false;
                userWordInput.disabled = false;
                return;
            }

            userInputArea.style.display = 'none';
            loadingElem.style.display = 'block';
            
            const nextSentence = await generateSentenceFromWord(trimmedWord);
            if (nextSentence === null) {
                loadingElem.style.display = 'none';
                const errorP = document.createElement('p');
                errorP.textContent = 'エラー：物語の生成に失敗しました。ページを再読み込みして、もう一度お試しください。';
                errorP.style.color = '#ff6b6b';
                errorP.style.fontWeight = 'bold';
                storyLogElem.appendChild(errorP);
                endOptionsContainer.innerHTML = `<button class="option-btn" onclick="location.reload()">最初からやり直す</button>`;
                return;
            }
            storyHistory.push(nextSentence);
            addSentenceToLog(nextSentence);
            choiceCount++;
            if (choiceCount >= 3) { await generateConclusion(); } else { await generateRecommendedWords(); }
        }

        async function generateRecommendedWords() {
            let currentAct = "", roleDescription = "", instruction = "";
            switch (choiceCount) {
                case 0: currentAct = "【承】"; roleDescription = `物語を「承」＝発展させる専門家です。`; instruction = `物語をさらに深く、面白く発展させるための、二つの具体的な「物の名前」の単語を提案してください。`; break;
                case 1: currentAct = "【転】"; roleDescription = `物語に「転」＝劇的な転換点をもたらす専門家です。`; instruction = `これまでの流れを根底から覆すような、衝撃的で、全く予測不可能な展開につながる、二つの完全にランダムな単語を提案してください。`; break;
                case 2: currentAct = "【結】"; roleDescription = `あなたは物語を「結」＝収束と結論に導く専門家です。`; instruction = `前の文で起きた衝撃的な展開をうまく収め、物語を結末へと向かわせるための、二つの対照的な「抽象的」な単語を提案してください。`; break;
            }
            actDisplayElem.textContent = currentAct;
            loadingElem.textContent = "物語の鍵となる単語を考えています...";
            loadingElem.style.display = 'block';
            const prompt = `# 役割: あなたは「${selectedTheme}」のスタイルを専門とする作家です。今回のあなたの役割は、${roleDescription}\n# 指示: ${instruction}\n# 制約: あなたの専門である「${selectedTheme}」の文体や雰囲気に合う単語を選んでください。回答は必ず {"word1": "単語1", "word2": "単語2"} のJSON形式のみで、説明やマークダウンは一切含めないでください。\n# 入力: これまでの物語:\n${storyHistory.join('\n')}\n# 出力:`;
            const data = await apiCallWithRetry(prompt);
            loadingElem.style.display = 'none';
            if (data) { updateUserInputArea(data); }
        }

        async function generateSentenceFromWord(word) {
            loadingElem.textContent = `「${word}」から物語を紡いでいます...`;
            let roleDescription = "", instruction = "";
            switch (choiceCount) {
                case 0: roleDescription = `物語を「承」＝発展させる専門家`; instruction = `与えられた単語「${word}」を使い、物語をさらに深く発展させる「次の一文」を生成してください。`; break;
                case 1: roleDescription = `物語に「転」＝劇的な転換点をもたらす専門家`; instruction = `与えられた単語「${word}」を使い、これまでの流れを根底から覆すような、衝撃的で、全く予測不可能な展開の「次の一文」を生成してください。`; break;
                case 2: roleDescription = `物語を「結」＝収束と結論に導く専門家`; instruction = `与えられた単語「${word}」を使い、前の文で起きた衝撃的な展開をうまく収め、物語を結末へと向かわせる「次の一文」を生成してください。`; break;
            }
            const prompt = `# 役割: あなたは「${selectedTheme}」のスタイルを専門とする、${roleDescription}です。\n# 指示: ${instruction}\n# 制約: あなたの専門である「${selectedTheme}」の文体や雰囲気を必ず維持してください。「次の一文」は、選ばれた単語「${word}」をとても強く反映させてください。「次の一文」は前の文章と文法的につながりを持たせてください。回答は必ず {"sentence": "生成された次の一文。"} のJSON形式のみで、説明やマークダウンは一切含めないでください。\n# 入力: これまでの物語:\n${storyHistory.join('\n')}\n# 出力:`;
            const data = await apiCallWithRetry(prompt);
            return data ? data.sentence : null;
        }

        async function generateConclusion() {
            actDisplayElem.style.display = 'none';
            loadingElem.textContent = "物語の結末を考えています...";
            loadingElem.style.display = 'block';
            const finalPrompt = `# 役割: あなたは「${selectedTheme}」のスタイルを専門とする、偉大なフィナーレを創造する作家です。\n# 指示: 以下の「これまでの物語」のすべてを読み、感動的または、衝撃的、あるいは心に残るような、「締めの一文」を生成してください。\n# 制約: あなたの専門である「${selectedTheme}」の文体や雰囲気に合わせてください。回答は必ず {"conclusion_sentence": "締めの一文。"} のJSON形式のみで、説明やマークダウンは一切含めないでください。\n# 入力: これまでの物語:\n${storyHistory.join('\n')}\n# 出力:`;
            const data = await apiCallWithRetry(finalPrompt);
            if (data && data.conclusion_sentence) { storyHistory.push(data.conclusion_sentence); addSentenceToLog(data.conclusion_sentence); } 
            else { const errorSentence = "（エラー：物語の締めの一文を生成できませんでした。）"; storyHistory.push(errorSentence); addSentenceToLog(errorSentence); }
            
            await generateCoverImage();
        }
        
        async function generateCoverImage() {
            loadingElem.textContent = "AIに画像生成を依頼中...";
            try {
                const requestResponse = await fetch('/api/request-image-generation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        storyHistory: storyHistory,
                        theme: selectedTheme
                    }),
                });

                if (!requestResponse.ok) {
                    throw new Error('画像生成リクエストの受付に失敗しました。');
                }

                const { jobId } = await requestResponse.json();
                pollForImageResult(jobId);

            } catch (error) {
                console.error('画像生成の依頼エラー:', error);
                loadingElem.textContent = "画像生成エラー";
                coverImageContainer.style.display = 'none';
            }
        }

        function pollForImageResult(jobId) {
            loadingElem.textContent = "AIが画像を生成しています...";
            
            const pollingInterval = setInterval(async () => {
                try {
                    const statusResponse = await fetch(`/api/check-image-status/${jobId}`);
                    if (!statusResponse.ok) {
                        clearInterval(pollingInterval);
                        loadingElem.textContent = "ステータス確認中にエラーが発生しました。";
                        return;
                    }

                    const result = await statusResponse.json();

                    if (result.status === 'completed') {
                        clearInterval(pollingInterval);
                        coverImageElem.src = `data:image/png;base64,${result.data}`;
                        
                        await new Promise((resolve, reject) => {
                            coverImageElem.onload = resolve;
                            coverImageElem.onerror = reject;
                        });

                        coverImageContainer.style.display = 'block';
                        loadingElem.textContent = "タイトルを作成しています...";
                        await generateAndShowTitle();
                        loadingElem.style.display = 'none';
                        showEnding();

                    } else if (result.status === 'failed') {
                        clearInterval(pollingInterval);
                        loadingElem.textContent = `画像生成に失敗しました: ${result.data}`;
                    
                    } else if (result.status === 'pending') {
                        console.log('画像生成中... ステータス: pending');
                    }

                } catch (error) {
                    clearInterval(pollingInterval);
                    console.error('ポーリングエラー:', error);
                    loadingElem.textContent = "ステータス確認エラー";
                }
            }, 3000); // 3秒ごとにステータスを確認
        }
        
        async function generateAndShowTitle() {
            const titlePrompt = `# 役割: あなたは優れた編集者です。\n# 指示: 以下の物語に最もふさわしい、タイトルを生成してください。\n# 制約: タイトルは「${selectedTheme}」の雰囲気に合っている必要があります。回答は必ず {"title": "生成されたタイトル"} のJSON形式のみで、説明やマークダウンは一切含めないでください。\n# 入力: 物語:\n${storyHistory.join('\n')}\n# 出力:`;
            const data = await apiCallWithRetry(titlePrompt);
            titleDisplayElem.textContent = (data && data.title) ? `『${data.title}』` : `『無題の物語』`;
            titleDisplayElem.style.display = 'block';
        }
        
        function addSentenceToLog(sentence) { const p = document.createElement('p'); p.textContent = sentence; storyLogElem.appendChild(p); storyLogElem.scrollTop = storyLogElem.scrollHeight; }

        function showEnding() {
            if (coverImageElem.src && coverImageElem.src.startsWith('data:image')) {
                coverImageContainer.style.display = 'block';
            }
            endOptionsContainer.innerHTML = `<button id="copy-btn" class="option-btn">タイトルと全文をコピー</button><button class="option-btn" onclick="location.reload()">新しい物語を始める</button>`;
            document.getElementById('copy-btn').addEventListener('click', copyStoryToClipboard);
            const endMark = document.createElement('p');
            endMark.textContent = "― 完 ―";
            endMark.style.textAlign = 'center';
            endMark.style.fontWeight = 'bold';
            endMark.style.marginTop = '2em';
            storyLogElem.appendChild(endMark);
        }

        async function copyStoryToClipboard() {
            const title = titleDisplayElem.textContent;
            const body = storyHistory.join('\n\n');
            const fullStory = `${title}\n\n${body}`;
            const copyButton = document.getElementById('copy-btn');
            try {
                await navigator.clipboard.writeText(fullStory);
                const originalText = copyButton.textContent;
                copyButton.textContent = 'コピーしました！';
                copyButton.disabled = true;
                setTimeout(() => { copyButton.textContent = originalText; copyButton.disabled = false; }, 2000);
            } catch (err) {
                console.error('クリップボードへのコピーに失敗しました:', err);
                alert('コピーに失敗しました。');
            }
        }
        
        function updateUserInputArea(data) {
            recommendOptions.innerHTML = '';
            userWordInput.value = '';
            const btn1 = document.createElement('button'); btn1.className = 'option-btn'; btn1.textContent = data.word1; btn1.onclick = () => proceedWithWord(data.word1);
            const btn2 = document.createElement('button'); btn2.className = 'option-btn'; btn2.textContent = data.word2; btn2.onclick = () => proceedWithWord(data.word2);
            recommendOptions.appendChild(btn1);
            recommendOptions.appendChild(btn2);
            userInputArea.style.display = 'block';

            submitWordBtn.disabled = false;
            userWordInput.disabled = false;
        }

        submitWordBtn.addEventListener('click', () => proceedWithWord(userWordInput.value));
        userWordInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') { proceedWithWord(userWordInput.value); } });
    </script>
</body>
</html>
```
